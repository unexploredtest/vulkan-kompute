name: wheels

on: [push]


# TODO: Build wheels for win32 bit as well
# Note: MacOS ARM builds are experiemental and there is no 
# guarantee that it'll work out, also, we can't test them
# TODO: Add official support to MacOS ARM once github adds
# Mac OS ARM as a runner and cibuildwheel officially support it

jobs: 
  wheels:
    
    strategy:
      fail-fast: false
      matrix:
        include:
          - runs-on: ubuntu-latest
            cibw-arch: manylinux_x86_64
            python-version: 3.7

            # aarch64 can take a long time
          - runs-on: ubuntu-latest
            cibw-arch: manylinux_i686
            python-version: 3.7
            vulkan-extra-arguemnts: -DCMAKE_C_FLAGS=-m32
            extra-apt-dependency: gcc-multilib g++-multilib
            
          - runs-on: ubuntu-latest
            cibw-arch: manylinux_aarch64
            python-version: 3.7
            vulkan-extra-arguemnts: -DCMAKE_C_COMPILER=aarch64-linux-gnu-gcc  -DCMAKE_CXX_COMPILER=aarch64-linux-gnu-g++
            extra-apt-dependency: gcc-aarch64-linux-gnu g++-aarch64-linux-gnu

          - runs-on: macos-latest
            cibw-arch: macosx_x86_64
            python-version: 3.7

          #- runs-on: macos-latest
            #cibw-arch: macosx_arm64
            #python-version: 3.7

          #- runs-on: macos-latest
            #cibw-arch: macosx_universal2
            #python-version: 3.7

          - runs-on: windows-latest
            cibw-arch: win_amd64
            python-version: 3.7

          #- runs-on: windows-latest
            #cibw-arch: win32
            #python-version: 3.7
            #python-arch: x86
            #vulkan-extra-arguemnts: -A Win32

    name: Wheels â€¢ ${{ matrix.cibw-arch }}
    runs-on: ${{ matrix.runs-on }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v2
        with:
          submodules: recursive
      
      - name: Setup Python
        uses: actions/setup-python@v2
        with:
          python-version: '${{ matrix.python-version }}'
          architecture: ${{ matrix.python-arch }}

       # Inspired from https://github.com/humbletim/setup-vulkan-sdk
      - name: Setup CMake
        uses: jwlawson/actions-setup-cmake@v1.8

      # Vulkan Loader needs some x11 related libraries
      # and ninja-build to build it from source
      - name: Install Vulkan Loader's Build Dependencies
        shell: bash
        run: |
          case `uname -s` in
            Linux)
              sudo apt-get install -y ninja-build libxrandr-dev gcc g++ ${{ matrix.extra-apt-dependency }}
          esac
        
      # Inspired from https://github.com/humbletim/setup-vulkan-sdk
      # Vulkan Kompute depends on Vulkan Loader so we will install it
      - name: Install Vulkan SDK
        shell: bash
        run: |
          VULKAN_VERSION=sdk-1.2.162
          mkdir VULKAN_SDK
          mkdir VULKAN_SDK/_build
          cd VULKAN_SDK/_build
          git clone https://github.com/KhronosGroup/Vulkan-Headers.git --branch $VULKAN_VERSION
          cd Vulkan-Headers
          cmake -DCMAKE_INSTALL_PREFIX=../.. -DCMAKE_BUILD_TYPE=Release ${{ matrix.vulkan-extra-arguemnts }} . 
          cmake --build . --config Release
          cmake --install .
          cd ..
          git clone https://github.com/KhronosGroup/Vulkan-Loader.git --branch $VULKAN_VERSION
          cd Vulkan-Loader
          cmake -DVULKAN_HEADERS_INSTALL_DIR=../.. -DCMAKE_INSTALL_PREFIX=../.. -DCMAKE_BUILD_TYPE=Release ${{ matrix.vulkan-extra-arguemnts }} . -DBUILD_WSI_WAYLAND_SUPPORT=OFF -DBUILD_WSI_XLIB_SUPPORT=OFF
          cmake --build . --config Release
          cmake --install .
          cd ../..
          rm -rf VULKAN_SDK/_build

        # cibuildwheel is used to build wheels and
        # twine to upload to PyPI
      - name: Install requirements
        run: |
          python -m pip install cibuildwheel twine

      - name: Set up QEMU
        if: matrix.cibw-arch == 'manylinux_aarch64'
        uses: docker/setup-qemu-action@v1
        with:
          platforms: arm64
          
      - name: Configure cibuildwheel
        shell: bash
        run: |
          CMAKE_ARCH="${{ matrix.cibw-arch == 'win32' && '-A Win32' || '' }}"
          CMAKE_OSX_ARCHITECTURES=${{ matrix.cibw-arch == 'macosx_x86_64' && 'x86_64' || matrix.cibw-arch == 'macosx_arm64' && 'arm64' || matrix.cibw-arch == 'macosx_universal2' && '"arm64;x86_64"' || '' }}
          echo "CIBW_ARCHS_MACOS=x86_64 arm64 universal2" >> $GITHUB_ENV
          echo "CIBW_ARCHS_LINUX=x86_64 aarch64 i686" >> $GITHUB_ENV
          # I'm not using manylinux2010 because it doesn't contain python3 libraries&headers that
          # pybind needs in order to build vulkan kompute, also, I think manylinux2014 is old enough
          echo "CIBW_MANYLINUX_X86_64_IMAGE=manylinux2014" >> $GITHUB_ENV
          echo "CIBW_MANYLINUX_AARCH64_IMAGE=manylinux2014" >> $GITHUB_ENV
          echo "CIBW_MANYLINUX_I686_IMAGE=manylinux2014" >> $GITHUB_ENV
          echo "CIBW_BUILD=*-${{ matrix.cibw-arch }}" >> $GITHUB_ENV
          # We're gonna skip python 2.7 builds because Vulkan Kompute only
          # supports python 3.5+
          # Vulkan Kompute doesn't work on PyPy yet, but will revisit this
          echo "CIBW_SKIP=cp27-* pp*" >> $GITHUB_ENV
          echo "CIBW_ENVIRONMENT=$CIBW_ENVIRONMENT_COMMON" >> $GITHUB_ENV
          echo "CIBW_ENVIRONMENT_LINUX=$CIBW_ENVIRONMENT_COMMON" >> $GITHUB_ENV
          CIBW_BEFORE_ALL_COMMON="cmake -S . -B build_dependencies -DCMAKE_BUILD_TYPE=Release -DKOMPUTE_OPT_INSTALL=1 -DKOMPUTE_OPT_ENABLE_SPDLOG=0"
          CIBW_BEFORE_ALL_COMMON="$CIBW_BEFORE_ALL_COMMON -DCMAKE_POSITION_INDEPENDENT_CODE=ON -DKOMPUTE_OPT_BUILD_PYTHON=1"
          CIBW_BEFORE_ALL_COMMON="$CIBW_BEFORE_ALL_COMMON -DKOMPUTE_OPT_REPO_SUBMODULE_BUILD=1 $CMAKE_ARCH && cmake --build build_dependencies -j 2"
          # We're not going to repair wheels, the reason is that we do not want to include vulkan libs
          # into wheels, as it SHOULD exist by default on a machine which has vulkan, otherwise
          # they haven't installed vulkan drivers at all, which is of course not going to work
          echo "CIBW_REPAIR_WHEEL_COMMAND_LINUX=""" >> $GITHUB_ENV
          echo "CIBW_REPAIR_WHEEL_COMMAND_MACOS=""" >> $GITHUB_ENV
          echo "CIBW_BEFORE_ALL=$CIBW_BEFORE_ALL_COMMON" >> $GITHUB_ENV
          # To build Vulkan Kompute, we need python3 libs; i.e libpython3.6m.so ,
          # if anyone wanted to change Manylinux image, install the corresponding
          # libraries, for example in manylinux_2_24 we would be using:
          # apt update && apt install python3-dev -y
          echo "CIBW_BEFORE_ALL_LINUX=yum install python3-devel && pip install cmake && ln -fs \$(which cmake) /usr/local/bin/cmake && $CIBW_BEFORE_ALL_COMMON" >> $GITHUB_ENV
          echo "CIBW_BEFORE_ALL_WINDOWS=$CIBW_BEFORE_ALL_COMMON --config Release" >> $GITHUB_ENV
      
      - name: Run cibuildwheel
        run: |
          cibuildwheel
      # Copying vulkan-1.dll to a place where python will find it
      - name: Copying vulkan-1.dll
        if: matrix.runs-on == 'windows-latest'
        run: xcopy VULKAN_SDK\bin C:\Windows\System32

      # Some mistakes might occure, generally if python tests have passed,
      # and the tests below(checking for kp classes) work, it's almost
      # guaranteed that it'llnick-invision@assert-action@v1s
      - name: Installing wheels
        if: matrix.cibw-arch != 'macosx_arm64' && matrix.cibw-arch != 'macosx_universal2'  && matrix.cibw-arch != 'manylinux_i686' && matrix.cibw-arch != 'manylinux_aarch64'
        shell: bash
        run: |
          # This case condition helps us specify vulkan lib
          # path for each OS (because it's a dependency)
          case `uname -s` in
            Darwin)
              export DYLD_LIBRARY_PATH="$(pwd)/VULKAN_SDK/lib:$DYLD_LIBRARY_PATH"
          esac
          python_version=$(python -c "print('${{ matrix.python-version }}'.replace('.', ''))")
          WANTED_WHEEL=$(find wheelhouse -iname "*$python_version*")
          pip install $WANTED_WHEEL
          
          # We're testing whether the class "Manager" exists ot not
          class_exists=$(python -c "import kp; class_exists = 'Manager' in dir(kp); print(str(class_exists).lower())")
          echo "class_exists=$class_exists" >> $GITHUB_ENV
      
      # If the class exists, then the test passes, else it'll fail
      - name: Testing wheels
        if: matrix.cibw-arch != 'macosx_arm64' && matrix.cibw-arch != 'macosx_universal2' && matrix.cibw-arch != 'manylinux_i686' && matrix.cibw-arch != 'manylinux_aarch64'
        uses: nick-invision/assert-action@v1
        with:
          expected: true
          actual: ${{ env.class_exists }}
          comparison: exact

      # Because we didn't use auditwheel, we have to change
      # linux to manylinux manually
      - name: Changing Linux wheel names
        shell: bash
        run: for filename in wheelhouse/*.whl; do mv "$filename" "${filename//linux/manylinux2014}"; done

      # Uploading wheels so that we can use them for the next job
      - name: Store wheels
        uses: actions/upload-artifact@v2
        with:
          name: wheels
          path: wheelhouse/*.whl

          
# This will automatically release kp to PyPI
  #publish:
    
    #name: Publish Wheels
    #runs-on: ubuntu-latest
    #needs: [wheels]

    #steps:

      # # Downloads the wheels that just got built
      #- uses: actions/download-artifact@v2
        #with:
          #name: wheels
          #path: dist

      #- name: Publish packages to PyPI
        #uses: pypa/gh-action-pypi-publish@release/v1
        #with:
          #user: __token__
          #password: ${{ secrets.PYPI_API_TOKEN }}
